---
title: "Example: Expression Analysis"
output:
  workflowr::wflow_html:
    toc: false
editor_options:
  chunk_output_type: console
---

### **Setup**

We consider the (raw) gene expression data measured over 16 days as studied in [Strober et al, 2019](https://www.science.org/doi/10.1126/science.aaw0040). 
For simplicity of the presentation, we consider only one cell-line in this example. 
The dataset contains the raw expression counts of 16319 genes.

To model the true (log) expression level $f_i(t_j)$ of the $i$th gene at day $t_j$, we assume that the expression count $y_{i}(t_j)$ is Poisson distributed with mean $o_j\exp \left(f_i\left(t_j\right)\right)$, where $o_j$ is the library size at day $t_j$.


```{r include=FALSE}
library(BayesGP)
library(TMB)
library(Matrix)
library(splines)
library(parallel)
library(ggplot2)
library(reshape2)
library(mixsqp)
library(tidyverse)
cpp_dir <- paste0(getwd(), "/code/cpp")
fig_dir <- paste0(getwd(), "/output/expression")
result_dir <- paste0(getwd(), "/output/expression")
function_dir <- paste0(getwd(), "/code/function")
data_dir <- paste0(getwd(), "/data/expression_data")
source(paste0(function_dir, "/functions_fitting_Poisson_expression.R"))
compile(paste0(cpp_dir, "/Poisson_expression.cpp"))
compile(paste0(cpp_dir, "/Poisson_just_fixed_expression.cpp"))
dyn.load(TMB::dynlib(paste0(cpp_dir, "/Poisson_expression")))
dyn.load(TMB::dynlib(paste0(cpp_dir, "/Poisson_just_fixed_expression")))
num_cores <- 4
betaprec <- 1e-6
```

### **Model**

Assume most of the gene expression trajectories are expected to be linear, we therefore consider the following finite mixture prior for each gene expression level $f_i(t_j)$:
$$f_i(t) = \sum_{k=0}^K \pi_k \text{GP}_k(t).$$
For each $k$, the mixture component has the prior: $$Lf(t) = \sigma_k W(t), $$ with $W(t)$ being a Gaussian white noise process and $\sigma_k$ being the smoothness. 
Choosing $L = \frac{\partial^2}{\partial t^2}$, the base model that each $f_i$ being shrunk to is therefore $\text{Null}\{L\} = \text{span}\{1,t\}$.


### **Processing the expression data**

```{r}
all_data_names <- list.files(data_dir)
#### let's consider one cell-line for simplicity
load(paste0(data_dir, "/", all_data_names[1]))
str(expression_data_one_cell_line) 
```

Let's create one dataset for each gene:
```{r eval=FALSE}
num_knots <- 16
p <- 2
datasets <- list()
all_gene <- unique(expression_data_one_cell_line$Gene_id)
for (gene in all_gene) {
  datasets[[gene]] <- expression_data_one_cell_line %>% filter(Gene_id == gene)
  datasets[[gene]]$x <- as.numeric(datasets[[gene]]$Day)
  datasets[[gene]]$y <- datasets[[gene]]$value
}
save(datasets, file = paste0(result_dir, "/datasets.rda"))
```


```{r echo=FALSE}
num_knots <- 16
p <- 2
datasets <- list()
all_gene <- unique(expression_data_one_cell_line$Gene_id)
load(paste0(result_dir, "/datasets.rda"))
```


Compute the library sizes:
```{r}
size_vec <- numeric(length = nrow(datasets[[1]]))
for (i in 1:length(size_vec)) {
  Day <- datasets[[1]]$Day[i]
  all_counts <-
    unlist(lapply(datasets, function(x) {
      x$y[x$Day == Day]
    }))
  size_vec[i] <- sum(all_counts)
}
log_size_vec <- log(size_vec)
```





### **Applying empirical Bayes**

```{r eval = FALSE}
psd_vec <- sort(unique(c(0, seq(0,3, length.out = 31))))

## set up a progress bar
L_vecs <- vector("list", length(datasets))
pb <- txtProgressBar(min = 0, max = length(datasets), style = 3)
for (i in 1:length(datasets)) {
  setTxtProgressBar(pb, i)
  dataset <- datasets[[i]]
  L_vecs[[i]] <- compute_log_likelihood_ospline_seq2(
    dataset = dataset,
    p = p,
    num_knots = num_knots,
    psd_iwp_vector = psd_vec,
    pred_step = 1,
    betaprec = betaprec,
    log_lib_size = log_size_vec
  )
}
L_matrix <- do.call(rbind, L_vecs)
save(L_matrix, file = paste0(result_dir, "/L_matrix.rda"))
```

```{r echo=FALSE}
psd_vec <- sort(unique(c(0, seq(0,3, length.out = 31))))
load(paste0(result_dir, "/L_matrix.rda"))
```

```{r}
fit.sqp <- mixsqp(L = L_matrix, log = TRUE)
numiter <- nrow(fit.sqp$progress)
plot(1:numiter,fit.sqp$progress$objective,type = "b",
     pch = 20,lwd = 2,xlab = "SQP iteration",
     ylab = "objective",xaxp = c(1,numiter,numiter - 1))
prior_weight <- data.frame(p = rep(p, each = length(psd_vec)), psd_iwp = psd_vec, prior_weight = fit.sqp$x)

posterior_matrix <- matrix(0, nrow = nrow(L_matrix), ncol = ncol(L_matrix))
for(i in 1:nrow(L_matrix)){
  posterior_matrix[i,] <- exp(L_matrix[i,] - max(L_matrix[i,]) + log(fit.sqp$x))
  posterior_matrix[i,] <- posterior_matrix[i,]/sum(posterior_matrix[i,])
}
colnames(posterior_matrix) <- paste0(p,"_",psd_vec)
posterior_weights_matrix <- posterior_matrix
```


### **Obtaining posteriors**

```{r, eval=FALSE}
num_datasets <- length(datasets)
num_weights <- sum(prior_weight$prior_weight != 0)
posterior_weights_matrix <- matrix(nrow = num_datasets, ncol = num_weights)

# Loop through each dataset and perform fitting
fitted_datasets <- list()
# create a progress bar
pb <- txtProgressBar(min = 0, max = num_datasets, style = 3)
for (i in seq_along(datasets)) {
  setTxtProgressBar(pb, i)
  dataset <- datasets[[i]]
  fit_result_final <- fit_ospline_with_prior2(
    num_cores = 1,
    dataset = dataset,
    num_knots = num_knots,
    prior_weight = prior_weight,
    betaprec = betaprec,
    pred_step = 1,
    log_lib_size = log_size_vec
  )
  posterior_weights_matrix[i, ] <- fit_result_final$posterior_weights[, "posterior_weight"]
  fitted_datasets[[i]] <- aggregate_fit_with_prior(x = dataset$x, fit_results_with_prior = fit_result_final, original = TRUE)$summary_df
}
names(fitted_datasets) <- all_gene
colnames(posterior_weights_matrix) <- paste(as.character(fit_result_final$posterior_weights[, "p"]),
                                            as.character(fit_result_final$posterior_weights[, "psd_iwp"]), sep = "_")
save(fitted_datasets, posterior_weights_matrix, file = paste0(result_dir, "/fitted_pos_results.rda"))
```

```{r}
posterior_weights_df <- as.data.frame(posterior_weights_matrix)
posterior_weights_df$id <- all_gene
melted_data <- melt(posterior_weights_df, id.vars = "id")
melted_data$variable2 <- sub("_.*", "", melted_data$variable)
melted_data$variable3 <- (round(as.numeric(sub("*._", "", melted_data$variable)), 3))
```

Plot a sorted version of this, based on the mean PSD in each gene:
```{r}
mean_psd <- apply(posterior_weights_matrix, 1, function(x) {
  weighted_psd <- as.numeric(sub("*._", "", colnames(posterior_weights_matrix)))
  sum(x * weighted_psd)
})
sorted_index <- order(mean_psd)
sorted_posterior_weights_matrix <- posterior_weights_matrix[sorted_index, ]
sorted_posterior_weights_df <- as.data.frame(sorted_posterior_weights_matrix)
sorted_posterior_weights_df$id <- all_gene[sorted_index]
melted_data_sorted <- melt(sorted_posterior_weights_df, id.vars = "id")
melted_data_sorted$variable2 <- sub("_.*", "", melted_data_sorted$variable)
melted_data_sorted$variable3 <- (round(as.numeric(sub("*._", "", melted_data_sorted$variable)), 3))

ggplot(melted_data_sorted, aes(x = factor(id, levels = sorted_posterior_weights_df$id), y = value, fill = variable3)) +
  geom_bar(stat = "identity") +
  labs(x = "Gene", y = "Weight", fill = "PSD") +
  ggtitle("Structure Plot of Posterior Weights") +
  coord_flip() +
  scale_fill_gradient(low = "white", high = "blue") +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),  
    panel.background = element_rect(fill = "white", colour = "grey"),
    plot.background = element_rect(fill = "white", colour = NA) 
  )
```



### **Clustering based on posterior weights**

Let's group them into `num_clusters` groups, based on the quantiles of the mean PSD:
```{r}
mean_psd_ordered <- mean_psd[sorted_index]
# num_clusters <- 22
# quantiles <- quantile(mean_psd_ordered, probs = seq(0, 1, 1/num_clusters))
quantiles <- c(0, 0.1, 0.2, 0.35, 0.5, 1, 1.7, 2.5, 2.95, 3)

quantile_groups <- cut(mean_psd_ordered, breaks = quantiles, 
                       include.lowest = TRUE, labels = FALSE)
table(quantile_groups)
num_clusters <- length(unique(quantile_groups))

sorted_posterior_weights_df$cluster <- quantile_groups
melted_data_quantiles <- melt(sorted_posterior_weights_df, id.vars = c("id", "cluster"))
melted_data_quantiles$variable2 <- sub("_.*", "", melted_data_quantiles$variable)
melted_data_quantiles$variable3 <- round(as.numeric(sub(".*_", "", melted_data_quantiles$variable)), 3)
melted_data_quantiles <- melted_data_quantiles %>% arrange(cluster)

# Ensure the 'id' factor is ordered according to the sorted mean_psd
melted_data_quantiles$id <- factor(melted_data_quantiles$id, levels = sorted_posterior_weights_df$id)

# Plotting with facets by cluster and proper sorting of 'id'
ggplot(melted_data_quantiles, aes(x = factor(id, levels = sorted_posterior_weights_df$id), y = value, fill = variable3)) +
  geom_bar(stat = "identity") +
  labs(x = "Gene", y = "Weight", fill = "PSD Level") +
  ggtitle("Structure Plot of Posterior Weights by Quantile Group") +
  coord_flip() +
  scale_fill_gradient(low = "white", high = "blue") +
  facet_wrap(~cluster, scales = "free_y") +  # Faceting by cluster while keeping order
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_rect(fill = "white", colour = "grey"),
    plot.background = element_rect(fill = "white", colour = NA),
    strip.background = element_rect(fill = "lightblue", colour = "deepskyblue", size = 1),
    strip.text = element_text(face = "bold")
  )
```

```{r setup, include=FALSE}
# Define the number of genes and clusters
num_genes_per_cluster <- 16

# Automatically extract gene IDs for each cluster
genes_per_cluster <- list()
for (i in 1:num_clusters) {
  genes_per_cluster[[i]] <- sorted_posterior_weights_df$id[sorted_posterior_weights_df$cluster == i][1:num_genes_per_cluster]
}
```



### **Question: What genes are enriched in each of the cluster? **

```{r, message = FALSE, warning = FALSE}
library(clusterProfiler)
library(msigdbr)
library(org.Hs.eg.db)  # Assuming human genes
library(biomaRt)
library(clusterProfiler)
library(cowplot)

# Retrieve Hallmark gene sets for Homo sapiens
m_t2g <- msigdbr(species = "Homo sapiens", category = "H") %>% 
  dplyr::select(gs_name, entrez_gene)
mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

enrich_cluster <- function(cluster_id, q_val_cutoff = 0.05, pvalueCutoff = 0.05, melted_data_input) {
  genes_selected <- melted_data_input %>% filter(cluster == cluster_id) %>% pull(id) %>% as.character() %>% unique()
  
  genes_converted <- getBM(
  filters = "ensembl_gene_id", 
  attributes = c("ensembl_gene_id", "entrezgene_id"), 
  values = genes_selected, 
  mart = mart
  )
  
  # Extract Entrez IDs from the converted data
  entrez_gene_list <- genes_converted$entrezgene_id
  
  genes_converted_all <- getBM(
    filters = "ensembl_gene_id", 
    attributes = c("ensembl_gene_id", "entrezgene_id"), 
    values = melted_data_input$id %>% as.character() %>% unique(), 
    mart = mart
  )
  entrez_universe <- as.character(genes_converted_all$entrezgene_id)
  entrez_universe <- entrez_universe[!is.na(entrez_universe)]

  # Perform enrichment analysis using Hallmark gene sets
  enrich_res <- enricher(pAdjustMethod = "BH", 
                         entrez_gene_list, 
                         TERM2GENE = m_t2g, 
                         qvalueCutoff = q_val_cutoff, 
                         pvalueCutoff = pvalueCutoff, 
                         universe = entrez_universe)
  enrich_res
}
```


```{r}
enriched_list <- list()
for (i in 1:num_clusters) {
  # for each cluster, record the list of its enriched gene sets
  enrich_res <- enrich_cluster(cluster_id = i, q_val_cutoff = 0.05, melted_data_input = melted_data_quantiles)  # Adjust parameters as needed
  enriched_list[[i]] <- enrich_res$Description
  names(enriched_list)[i] <- paste0(i)
}

# Automatically create a list of all unique enriched terms
all_enriched_terms <- unique(unlist(enriched_list))

# Remove the "HALLMARK_" prefix from each term
all_enriched_terms_clean <- gsub("HALLMARK_", "", all_enriched_terms)

# Initialize a data frame with clusters as columns and terms as rows
enrichment_table <- data.frame(matrix(nrow = length(all_enriched_terms_clean), ncol = length(enriched_list)))
rownames(enrichment_table) <- all_enriched_terms_clean
colnames(enrichment_table) <- names(enriched_list)

# Fill the table with "yes" or "no"
for (cluster in names(enriched_list)) {
  for (term in all_enriched_terms_clean) {
    # Check if the term is present in the enriched list of the cluster (after removing "HALLMARK_")
    original_term <- paste0("HALLMARK_", term)  # Add back the prefix for comparison
    enrichment_table[term, cluster] <- ifelse(original_term %in% enriched_list[[cluster]], "yes", "no")
  }
}

# Display the resulting table
print(enrichment_table[,-2])
```



```{r eval = FALSE}
enriched_list <- list()  # To store enrichment results

for (i in 1:num_clusters) {
  # For each cluster, perform enrichment and store the results
  enrich_res <- enrich_cluster(cluster_id = i, q_val_cutoff = 1, melted_data = melted_data_quantiles)  # Set q_val_cutoff to 1 to ensure all p-values are returned
  
  # Store both the descriptions and p-values (not filtered by significance)
  enriched_list[[i]] <- data.frame(
    Description = enrich_res$Description, 
    PValue = enrich_res$pvalue  # Use the raw p-value
  )
  
  names(enriched_list)[i] <- paste0(i)
}

# Automatically create a list of all unique enriched terms
all_enriched_terms <- unique(unlist(lapply(enriched_list, function(x) x$Description)))

# Remove the "HALLMARK_" prefix from each term
all_enriched_terms_clean <- gsub("HALLMARK_", "", all_enriched_terms)

# Initialize a data frame with clusters as columns and terms as rows
enrichment_table <-
  data.frame(matrix(
    nrow = length(all_enriched_terms_clean),
    ncol = length(enriched_list)
  ))
rownames(enrichment_table) <- all_enriched_terms_clean
colnames(enrichment_table) <- names(enriched_list)

# Fill the table with p-values
for (cluster in names(enriched_list)) {
  for (term in all_enriched_terms_clean) {
    # Check if the term is present in the enriched list of the cluster
    original_term <- paste0("HALLMARK_", term)  # Add back the prefix for comparison
    term_in_cluster <- if (nrow(enriched_list[[cluster]]) > 0) {
      enriched_list[[cluster]]$Description == original_term
    } else {
      FALSE
    }
    
    # If the term is enriched, fill in the p-value; otherwise, compute the enrichment and add its p-value
    if (any(term_in_cluster)) {
      enrichment_table[term, cluster] <- round(enriched_list[[cluster]]$PValue[term_in_cluster], 3)
    } 
    else {
      # If not found in the original result, perform enrichment for the gene set specifically
      cluster_id <- as.numeric(cluster)
      genes_selected <- melted_data_quantiles %>% filter(cluster == cluster_id) %>% pull(id) %>% as.character() %>% unique()
      
      genes_converted <- getBM(
        filters = "ensembl_gene_id",
        attributes = c("ensembl_gene_id", "entrezgene_id"),
        values = genes_selected,
        mart = mart
      )
      
      # Extract Entrez IDs from the converted data
      entrez_gene_list <- genes_converted$entrezgene_id
      
      genes_converted_all <- getBM(
        filters = "ensembl_gene_id",
        attributes = c("ensembl_gene_id", "entrezgene_id"),
        values = melted_data_quantiles$id %>% as.character() %>% unique(),
        mart = mart
      )
      entrez_universe <- as.character(genes_converted_all$entrezgene_id)
      entrez_universe <- entrez_universe[!is.na(entrez_universe)]
      
      enrich_res_full <- enricher(entrez_gene_list,
                 TERM2GENE = m_t2g,
                 pvalueCutoff = 2, qvalueCutoff = 2,
                 universe = entrez_universe)
      
      
      specific_term <- enrich_res_full %>% filter(Description == original_term)
      
      # Add p-value if it exists
      if (nrow(specific_term) > 0) {
        enrichment_table[term, cluster] <- round(specific_term$p.adjust, 3)
      } else {
        enrichment_table[term, cluster] <- 1  # No p-value found
      }
    }
  }
}

# Display the resulting table with p-values
print(enrichment_table)
```



### **Question: What enriched gene sets were not enriched in Strober's analysis? **

Here are the enrichment result from Strober's analysis for comparison:

```{r echo=FALSE}
# Define the file path where the table is saved
file_path <- paste0(result_dir, "/gene_set_table_strober")

# Load the table using read.table, assuming tab-delimited format
gene_set_table <- read.table(file_path, header = TRUE, sep = "|", stringsAsFactors = FALSE, strip.white = TRUE)

# Optionally, you can remove any unnecessary row numbers or empty rows
gene_set_table <- gene_set_table[-1,]  # Remove the first row if it's a redundant header row
gene_set_table <- gene_set_table[, -1] # Remove the first column if it's a redundant row index
gene_set_table <- gene_set_table[, -ncol(gene_set_table)] # remove the last column

# Clean up column names (since separators may have caused extra spaces)
colnames(gene_set_table) <- c("Hallmark", 2, 4, 5, 6, 9, 11, 13, 16)

# If you want to handle NA values that result from conversion
gene_set_table[is.na(gene_set_table)] <- 0  # Replace NAs with 0, or handle them as needed

# Perform a comparison between the two tables
gene_set_table_strober <- gene_set_table 

# Define the significance threshold
significance_level <- 0.05

# Apply the conversion using ifelse for each relevant column
for (col in colnames(gene_set_table)[2:ncol(gene_set_table)]) {
  gene_set_table[[col]] <- ifelse(as.numeric(gene_set_table[[col]]) < significance_level, "yes", "no")
}

gene_set_table$Hallmark <- toupper(gsub(" ", "_", gene_set_table$Hallmark))

# Define the desired order based on enrichment_table
desired_order <- rownames(enrichment_table)

# Step 1: Get the union of gene sets from both tables
all_gene_sets <- unique(c(gene_set_table$Hallmark, desired_order))

# Step 2: Identify gene sets in the union that are missing from final_gene_set_table
missing_gene_sets <- setdiff(all_gene_sets, gene_set_table$Hallmark)

# Step 3: Create a data frame for the missing gene sets, with all values set to "no"
missing_rows <- data.frame(Hallmark = missing_gene_sets, matrix("no", nrow = length(missing_gene_sets), ncol = ncol(gene_set_table) - 1))
colnames(missing_rows) <- colnames(gene_set_table)

# Step 4: Add the missing rows to the final_gene_set_table
final_gene_set_table <- rbind(gene_set_table, missing_rows)

# Step 5: Reorder the rows of the final table to match the order of the union of gene sets
final_gene_set_table <- final_gene_set_table[match(all_gene_sets, final_gene_set_table$Hallmark), ]


final_gene_set_table_for_comparison <- final_gene_set_table %>% filter(Hallmark %in% desired_order)
final_gene_set_table_for_comparison <- final_gene_set_table_for_comparison[match(desired_order, final_gene_set_table_for_comparison$Hallmark), ]

get_first_yes_position <- function(column) {
  yes_positions <- which(column == "yes")
  if (length(yes_positions) == 0) {
    return(Inf)  # Return Inf if there are no "yes" entries
  } else {
    return(min(yes_positions))  # Return the position of the first "yes"
  }
}

# Apply the function to each column (excluding the Hallmark column)
column_order <- apply(final_gene_set_table_for_comparison[, -1], 2, get_first_yes_position)
# Reorder the columns based on the first "yes" position
ordered_columns <- order(column_order)
# Reorder the table's columns based on this order
final_gene_set_table_for_comparison <- final_gene_set_table_for_comparison[, c(1, ordered_columns + 1)]  # +1 to account for the Hallmark column
rownames(final_gene_set_table_for_comparison) <- final_gene_set_table_for_comparison$Hallmark
final_gene_set_table_for_comparison[,-1]
```

A few interesting observations:

- Many gene-sets are enriched in clusters identified from both approaches. In particular, cluster 7 from FASH identified MYOGENESIS, EPITHELIAL_MESENCHYMAL_TRANSITION, INFLAMMATORY_RESPONSE and TNFA_SIGNALING_VIA_NFKB as enriched gene sets, whereas the cluster 6 from Strober identified MYOGENESIS, EPITHELIAL_MESENCHYMAL_TRANSITION and TNFA_SIGNALING_VIA_NFKB.

- Clusters (especially cluster 9) from FASH identifies some interesting gene-sets that were missed by Strober's analysis, such as UV_RESPONSE_DN, INFLAMMATORY_RESPONSE, IL2_STAT5_SIGNALING, ANGIOGENESIS and HYPOXIA. Note that UV_RESPONSE_DN INFLAMMATORY_RESPONSE and IL2_STAT5_SIGNALING are all related to protective features to prevent external damage due to environment or pathogens. ANGIOGENESIS and HYPOXIA are related to the formation of new blood vessels and the response to low oxygen levels, respectively.




### **Question: What are the main features of gene-expression trajectories identified in each cluster? **

```{r}
load(paste0(result_dir, "/fitted_pos_results1.rda"))
load(paste0(result_dir, "/datasets_1.rda"))
```


#### From cluster 9:

Let's first look at `ANGIOGENESIS` gene set in cluster 9:

```{r echo=FALSE}
ANGIOGENESIS_genes_entrez <- m_t2g$entrez_gene[m_t2g$gs_name == "HALLMARK_ANGIOGENESIS"]

cluster9_genes <- sorted_posterior_weights_df %>% filter(cluster == 9) %>% pull(id)

cluster9_genes_converted <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "entrezgene_id"),
  values = cluster9_genes,
  mart = mart
)

cluster9_genes_entrez <- cluster9_genes_converted$entrezgene_id
overlap_genes_entrez <- intersect(ANGIOGENESIS_genes_entrez, cluster9_genes_entrez)
overlap_genes <- cluster9_genes_converted$ensembl_gene_id[cluster9_genes_converted$entrezgene_id %in% overlap_genes_entrez]

sample_index <- 1:length(overlap_genes)
fitted_datasets_selected <- fitted_datasets[overlap_genes]
plot_min <- fitted_datasets_selected %>% lapply(function(x) min(x$median/exp(log_size_vec))) %>% unlist() %>% min()
plot_max <- fitted_datasets_selected %>% lapply(function(x) max(x$median/exp(log_size_vec))) %>% unlist() %>% max()

par(mfrow = c(2,4))
for (i in 1:length(overlap_genes)) {
  gene = overlap_genes[sample_index[i]]
  agg_result <- fitted_datasets_selected[[gene]]
  agg_result[,c(2,3,4)] <-  agg_result[,c(2,3,4)]/exp(log_size_vec)

  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", 
       ylim = c(plot_min, plot_max),
       log = "y",
       col = "blue",
       cex = 0.5, 
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}
par(mfrow = c(1, 1))
```

Then, look at `UV_RESPONSE_DN` gene set in cluster 9:

```{r echo=FALSE}
UV_RESPONSE_DN_genes_entrez <- m_t2g$entrez_gene[m_t2g$gs_name == "HALLMARK_UV_RESPONSE_DN"]

cluster9_genes <- sorted_posterior_weights_df %>% filter(cluster == 9) %>% pull(id)

cluster9_genes_converted <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "entrezgene_id"),
  values = cluster9_genes,
  mart = mart
)

cluster9_genes_entrez <- cluster9_genes_converted$entrezgene_id
overlap_genes_entrez <- intersect(UV_RESPONSE_DN_genes_entrez, cluster9_genes_entrez)
overlap_genes <- cluster9_genes_converted$ensembl_gene_id[cluster9_genes_converted$entrezgene_id %in% overlap_genes_entrez]

sample_index <- 1:length(overlap_genes)
fitted_datasets_selected <- fitted_datasets[overlap_genes]
plot_min <- fitted_datasets_selected %>% lapply(function(x) min(x$median/exp(log_size_vec))) %>% unlist() %>% min()
plot_max <- fitted_datasets_selected %>% lapply(function(x) max(x$median/exp(log_size_vec))) %>% unlist() %>% max()

par(mfrow = c(3,4))
for (i in 1:length(overlap_genes)) {
  gene = overlap_genes[sample_index[i]]
  agg_result <- fitted_datasets_selected[[gene]]
  agg_result[,c(2,3,4)] <-  agg_result[,c(2,3,4)]/exp(log_size_vec)

  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", 
       ylim = c(plot_min, plot_max),
       log = "y",
       col = "blue",
       cex = 0.5, 
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}
par(mfrow = c(1, 1))
```

And, `HYPOXIA` in cluster 9:

```{r echo=FALSE}
HYPOXIA_genes_entrez <- m_t2g$entrez_gene[m_t2g$gs_name == "HALLMARK_HYPOXIA"]

cluster9_genes <- sorted_posterior_weights_df %>% filter(cluster == 9) %>% pull(id)

cluster9_genes_converted <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "entrezgene_id"),
  values = cluster9_genes,
  mart = mart
)

cluster9_genes_entrez <- cluster9_genes_converted$entrezgene_id
overlap_genes_entrez <- intersect(HYPOXIA_genes_entrez, cluster9_genes_entrez)
overlap_genes <- cluster9_genes_converted$ensembl_gene_id[cluster9_genes_converted$entrezgene_id %in% overlap_genes_entrez]

sample_index <- 1:length(overlap_genes)
fitted_datasets_selected <- fitted_datasets[overlap_genes]
plot_min <- fitted_datasets_selected %>% lapply(function(x) min(x$median/exp(log_size_vec))) %>% unlist() %>% min()
plot_max <- fitted_datasets_selected %>% lapply(function(x) max(x$median/exp(log_size_vec))) %>% unlist() %>% max()

par(mfrow = c(3,4))
for (i in 1:12) {
  gene = overlap_genes[sample_index[i]]
  agg_result <- fitted_datasets_selected[[gene]]
  agg_result[,c(2,3,4)] <-  agg_result[,c(2,3,4)]/exp(log_size_vec)
  
  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", 
       ylim = c(plot_min, plot_max),
       log = "y",
       col = "blue",
       cex = 0.5, 
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}
par(mfrow = c(1, 1))
```


#### From cluster 8:

Take a look at `EPITHELIAL_MESENCHYMAL_TRANSITION`

```{r echo=FALSE}
EPITHELIAL_MESENCHYMAL_TRANSITION_genes_entrez <- m_t2g$entrez_gene[m_t2g$gs_name == "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION"]
cluster8_genes <- sorted_posterior_weights_df %>% filter(cluster == 8) %>% pull(id)
cluster8_genes_converted <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "entrezgene_id"),
  values = cluster8_genes,
  mart = mart
)
cluster8_genes_entrez <- cluster8_genes_converted$entrezgene_id
overlap_genes_entrez <- intersect(EPITHELIAL_MESENCHYMAL_TRANSITION_genes_entrez, cluster8_genes_entrez)
overlap_genes <- cluster8_genes_converted$ensembl_gene_id[cluster8_genes_converted$entrezgene_id %in% overlap_genes_entrez]

sample_index <- 1:length(overlap_genes)
fitted_datasets_selected <- fitted_datasets[overlap_genes]
plot_min <- fitted_datasets_selected %>% lapply(function(x) min(x$median/exp(log_size_vec))) %>% unlist() %>% min()
plot_max <- fitted_datasets_selected %>% lapply(function(x) max(x$median/exp(log_size_vec))) %>% unlist() %>% max()

par(mfrow = c(3,4))
for (i in 1:12) {
  gene = overlap_genes[sample_index[i]]
  agg_result <- fitted_datasets_selected[[gene]]
  agg_result[,c(2,3,4)] <-  agg_result[,c(2,3,4)]/exp(log_size_vec)
  
  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", 
       ylim = c(plot_min, plot_max),
       log = "y",
       col = "blue",
       cex = 0.5, 
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
    
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}
par(mfrow = c(1, 1))
```


#### From cluster 7:

Take a look at `INFLAMMATORY_RESPONSE`

```{r echo=FALSE}
INFLAMMATORY_RESPONSE_genes_entrez <- m_t2g$entrez_gene[m_t2g$gs_name == "HALLMARK_INFLAMMATORY_RESPONSE"]
cluster7_genes <- sorted_posterior_weights_df %>% filter(cluster == 7) %>% pull(id)
cluster7_genes_converted <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "entrezgene_id"),
  values = cluster7_genes,
  mart = mart
)
cluster7_genes_entrez <- cluster7_genes_converted$entrezgene_id
overlap_genes_entrez <- intersect(INFLAMMATORY_RESPONSE_genes_entrez, cluster7_genes_entrez)
overlap_genes <- cluster7_genes_converted$ensembl_gene_id[cluster7_genes_converted$entrezgene_id %in% overlap_genes_entrez]

sample_index <- 1:length(overlap_genes)
fitted_datasets_selected <- fitted_datasets[overlap_genes]
plot_min <- fitted_datasets_selected %>% lapply(function(x) min(x$median/exp(log_size_vec))) %>% unlist() %>% min()
plot_max <- fitted_datasets_selected %>% lapply(function(x) max(x$median/exp(log_size_vec))) %>% unlist() %>% max()

par(mfrow = c(3,4))
for (i in 1:12) {
  gene = overlap_genes[sample_index[i]]
  agg_result <- fitted_datasets_selected[[gene]]
  agg_result[,c(2,3,4)] <-  agg_result[,c(2,3,4)]/exp(log_size_vec)
  
  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", 
       ylim = c(plot_min, plot_max),
       log = "y",
       col = "blue",
       cex = 0.5, 
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}
par(mfrow = c(1, 1))
```


#### From cluster 6:

Take a look at `IL2_STAT5_SIGNALING`

```{r echo=FALSE}
IL2_STAT5_SIGNALING_genes_entrez <- m_t2g$entrez_gene[m_t2g$gs_name == "HALLMARK_IL2_STAT5_SIGNALING"]
cluster6_genes <- sorted_posterior_weights_df %>% filter(cluster == 6) %>% pull(id)
cluster6_genes_converted <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "entrezgene_id"),
  values = cluster6_genes,
  mart = mart
)
cluster6_genes_entrez <- cluster6_genes_converted$entrezgene_id
overlap_genes_entrez <- intersect(IL2_STAT5_SIGNALING_genes_entrez, cluster6_genes_entrez)
overlap_genes <- cluster6_genes_converted$ensembl_gene_id[cluster6_genes_converted$entrezgene_id %in% overlap_genes_entrez]
sample_index <- 1:length(overlap_genes)
fitted_datasets_selected <- fitted_datasets[overlap_genes]
plot_min <- fitted_datasets_selected %>% lapply(function(x) min(x$median/exp(log_size_vec))) %>% unlist() %>% min()
plot_max <- fitted_datasets_selected %>% lapply(function(x) max(x$median/exp(log_size_vec))) %>% unlist() %>% max()

par(mfrow = c(3,4))
for (i in 1:12) {
  gene = overlap_genes[sample_index[i]]
  agg_result <- fitted_datasets_selected[[gene]]
  agg_result[,c(2,3,4)] <-  agg_result[,c(2,3,4)]/exp(log_size_vec)
  
  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", 
       ylim = c(plot_min, plot_max),
       log = "y",
       col = "blue",
       cex = 0.5, 
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}
par(mfrow = c(1, 1))
```



#### From cluster 3:

Take a look at `MYC_TARGETS_V2`

```{r echo=FALSE}
MYC_TARGETS_V2_genes_entrez <- m_t2g$entrez_gene[m_t2g$gs_name == "HALLMARK_MYC_TARGETS_V2"]
cluster3_genes <- sorted_posterior_weights_df %>% filter(cluster == 3) %>% pull(id)
cluster3_genes_converted <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "entrezgene_id"),
  values = cluster3_genes,
  mart = mart
)
cluster3_genes_entrez <- cluster3_genes_converted$entrezgene_id
overlap_genes_entrez <- intersect(MYC_TARGETS_V2_genes_entrez, cluster3_genes_entrez)
overlap_genes <- cluster3_genes_converted$ensembl_gene_id[cluster3_genes_converted$entrezgene_id %in% overlap_genes_entrez]

sample_index <- 1:12
fitted_datasets_selected <- fitted_datasets[overlap_genes]
plot_min <- fitted_datasets_selected %>% lapply(function(x) min(x$median/exp(log_size_vec))) %>% unlist() %>% min()
plot_max <- fitted_datasets_selected %>% lapply(function(x) max(x$median/exp(log_size_vec))) %>% unlist() %>% max()

par(mfrow = c(3,4))
for (i in 1:12) {
  gene = overlap_genes[sample_index[i]]
  agg_result <- fitted_datasets_selected[[gene]]
  agg_result[,c(2,3,4)] <-  agg_result[,c(2,3,4)]/exp(log_size_vec)

  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", 
       ylim = c(plot_min, plot_max),
       log = "y",
       col = "blue",
       cex = 0.5, 
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}
par(mfrow = c(1, 1))
```

#### From cluster 1:

Take a look at `BILE_ACID_METABOLISM`

```{r echo=FALSE}
BILE_ACID_METABOLISM_genes_entrez <- m_t2g$entrez_gene[m_t2g$gs_name == "HALLMARK_BILE_ACID_METABOLISM"]
cluster1_genes <- sorted_posterior_weights_df %>% filter(cluster == 1) %>% pull(id)
cluster1_genes_converted <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "entrezgene_id"),
  values = cluster1_genes,
  mart = mart
)
  
cluster1_genes_entrez <- cluster1_genes_converted$entrezgene_id
overlap_genes_entrez <- intersect(BILE_ACID_METABOLISM_genes_entrez, cluster1_genes_entrez)
overlap_genes <- cluster1_genes_converted$ensembl_gene_id[cluster1_genes_converted$entrezgene_id %in% overlap_genes_entrez]

sample_index <- 1:length(overlap_genes)
fitted_datasets_selected <- fitted_datasets[overlap_genes]
plot_min <- fitted_datasets_selected %>% lapply(function(x) min(x$median/exp(log_size_vec))) %>% unlist() %>% min()
plot_max <- fitted_datasets_selected %>% lapply(function(x) max(x$median/exp(log_size_vec))) %>% unlist() %>% max()

par(mfrow = c(2,3))
for (i in 1:5) {
  gene = overlap_genes[sample_index[i]]
  agg_result <- fitted_datasets_selected[[gene]]
  agg_result[,c(2,3,4)] <-  agg_result[,c(2,3,4)]/exp(log_size_vec)

  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", 
       ylim = c(plot_min, plot_max),
       log = "y",
       col = "blue",
       cex = 0.5, 
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}
par(mfrow = c(1, 1))
```





### **Analysis Across Cell-lines**

```{r echo=FALSE, message=FALSE, warning=FALSE}
library(gridExtra)

plot_gene_expression <- function(gene, cell_line_index) {
  load(paste0(result_dir, "/fitted_pos_results", cell_line_index, ".rda"))
  load(paste0(result_dir, "/datasets_", cell_line_index, ".rda"))
  agg_result <- fitted_datasets[[gene]]
  plot(
    datasets[[gene]]$Day,
    agg_result$median,
    type = 'l',
    main = paste0(gene),
    xlab = "Day",
    ylab = "Expression",
    col = "blue",
    cex = 0.5,
    ylim = c(0, max(datasets[[gene]]$y) * 1.2),
    cex.main = 0.8,
    cex.lab = 0.7,
    cex.axis = 0.7
  )
  points(datasets[[gene]]$Day,
         datasets[[gene]]$y,
         col = "black",
         cex = 0.5)
  polygon(
    c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
    c(agg_result$lower, rev(agg_result$upper)),
    col = rgb(0.6, 0.8, 1, alpha = 0.3),
    border = NA
  )
}

plot_gene_expression_across_cell_lines <-
  function(gene, cell_line_indices) {
    # Initialize an empty list to store data for plotting
    plot_data <- list()
    
    # Loop over each cell line index
    for (cell_line_index in cell_line_indices) {
      # Load results and datasets for the current cell line
      result_file <-
        paste0(result_dir,
               "/fitted_pos_results",
               cell_line_index,
               ".rda")
      dataset_file <-
        paste0(result_dir, "/datasets_", cell_line_index, ".rda")
      
      if (file.exists(result_file) && file.exists(dataset_file)) {
        load(result_file)
        load(dataset_file)
        
        # Extract aggregated results and days for the specified gene
        if (gene %in% names(fitted_datasets) &&
            gene %in% names(datasets)) {
          agg_result <- fitted_datasets[[gene]]
          day <- datasets[[gene]]$Day
          plot_data[[cell_line_index]] <- data.frame(
            Day = day,
            Median = agg_result$median,
            CellLine = paste0("Cell Line ", cell_line_index)
          )
        } else {
          message(paste("Gene", gene, "not found in cell line", cell_line_index))
        }
      } else {
        message(paste("Data not found for cell line", cell_line_index))
      }
    }
    
    # Combine all data into a single data frame
    plot_data_combined <- bind_rows(plot_data)
    
    # Generate the plot using ggplot2
    ggplot(plot_data_combined,
           aes(
             x = Day,
             y = Median,
             color = CellLine,
             group = CellLine
           )) +
      geom_line(size = 1) +
      labs(
        title = paste("Posterior Median of", gene, "Across Cell Lines"),
        x = "Day",
        y = "Expression",
        color = "Cell Line"
      ) +
      theme_minimal() +
      theme(
        plot.title = element_text(size = 14, face = "bold"),
        axis.title = element_text(size = 12),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 9)
      )
  }

plot_gene_expression_log_just_f <- function(gene, cell_line_index) {
  load(paste0(result_dir, "/fitted_pos_results", cell_line_index, ".rda"))
  load(paste0(result_dir, "/datasets_", cell_line_index, ".rda"))
  size_vec <- numeric(length = nrow(datasets[[1]]))
  for (i in 1:length(size_vec)) {
    Day <- datasets[[1]]$Day[i]
    all_counts <-
      unlist(lapply(datasets, function(x) {
        x$y[x$Day == Day]
      }))
    size_vec[i] <- sum(all_counts)
  }
  log_size_vec <- log(size_vec)
  
  log_size_vec <- log(size_vec)
  agg_result <- fitted_datasets[[gene]]
  agg_result[, c(2, 3, 4)] <-
    agg_result[, c(2, 3, 4)] / exp(log_size_vec)
  min_y <- min(agg_result$lower)
  max_y <-
    max(agg_result$upper)  # Assuming this is positive and makes sense in your context
  
  # Set the limits for the y-axis
  log_min_y <- min_y / 2
  log_max_y <- max_y * 1.2
  
  plot(
    datasets[[gene]]$Day,
    agg_result$median,
    type = 'l',
    main = paste0(gene),
    xlab = "Day",
    ylab = "Expression",
    col = "blue",
    cex = 0.5,
    cex.main = 0.8,
    cex.lab = 0.7,
    cex.axis = 0.7
  )
  polygon(
    c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
    c(agg_result$lower, rev(agg_result$upper)),
    col = rgb(0.6, 0.8, 1, alpha = 0.3),
    border = NA
  )
}

plot_gene_expression_log_across_cell_lines <- 
  function(gene, cell_line_indices, color = T, CI = F) {
  # Initialize an empty list to store data for plotting
  plot_data <- list()

  # Loop over each cell line index
  for (cell_line_index in cell_line_indices) {
    # Load results and datasets for the current cell line
    result_file <- paste0(result_dir, "/fitted_pos_results", cell_line_index, ".rda")
    dataset_file <- paste0(result_dir, "/datasets_", cell_line_index, ".rda")

    if (file.exists(result_file) && file.exists(dataset_file)) {
      load(result_file)
      load(dataset_file)

      # Calculate size vector for normalization
      size_vec <- numeric(length = nrow(datasets[[1]]))
      for (i in 1:length(size_vec)) {
        Day <- datasets[[1]]$Day[i]
        all_counts <- unlist(lapply(datasets, function(x) { x$y[x$Day == Day] }))
        size_vec[i] <- sum(all_counts)
      }
      log_size_vec <- log(size_vec)

      # Extract aggregated results and normalize by size vector
      if (gene %in% names(fitted_datasets) && gene %in% names(datasets)) {
        agg_result <- fitted_datasets[[gene]]
        agg_result[, c("median", "lower", "upper")] <- agg_result[, c("median", "lower", "upper")] / exp(log_size_vec)

        # Prepare data for plotting
        plot_data[[cell_line_index]] <- data.frame(
          Day = datasets[[gene]]$Day,
          Median = agg_result$median,
          Lower = agg_result$lower,
          Upper = agg_result$upper,
          CellLine = paste0("Cell Line ", cell_line_index)
        )
      } else {
        message(paste("Gene", gene, "not found in cell line", cell_line_index))
      }
    } else {
      message(paste("Data not found for cell line", cell_line_index))
    }
  }

  # Combine all data into a single data frame
  plot_data_combined <- bind_rows(plot_data)

  # Base ggplot
  p <- ggplot(plot_data_combined, aes(x = Day, y = Median, group = CellLine)) +
    geom_line(size = 0.5, aes(color = CellLine)) +
    labs(
      # title = paste("Normalized Expression of", gene, "Across Cell Lines"),
      title = gene,
      x = "Day",
      y = "Normalized Expression"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(size = 12)
    )

  # Apply single pink color if color = FALSE
  if (!color) {
    pink_color <- rgb(1, 0.4, 0.6, alpha = 0.6)  # Define a pink color with transparency
    p <- p +
      geom_line(size = 1, color = pink_color) +  # Set line color explicitly
      guides(color = "none")
  }

  # Add confidence intervals if CI is TRUE
  if (CI) {
    if (color) {
      p <- p + geom_ribbon(aes(ymin = Lower, ymax = Upper, fill = CellLine), alpha = 0.2, color = NA)
    } else {
      pink_color <- rgb(1, 0.4, 0.6, alpha = 0.2)  # Transparent pink for ribbon
      p <- p + geom_ribbon(aes(ymin = Lower, ymax = Upper), fill = pink_color, alpha = 0.2, color = NA) +
        guides(fill = "none")
    }
  }

  # Return the plot
  return(p)
}
```

Let's first look at `ANGIOGENESIS` gene set in cluster 9 across cell lines:

```{r echo=FALSE, message=FALSE}
ANGIOGENESIS_genes_entrez <- m_t2g$entrez_gene[m_t2g$gs_name == "HALLMARK_ANGIOGENESIS"]
cluster9_genes <- sorted_posterior_weights_df %>% filter(cluster == 9) %>% pull(id)
cluster9_genes_converted <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "entrezgene_id"),
  values = cluster9_genes,
  mart = mart
)
cluster9_genes_entrez <- cluster9_genes_converted$entrezgene_id
overlap_genes_entrez <- intersect(ANGIOGENESIS_genes_entrez, cluster9_genes_entrez)
overlap_genes <- cluster9_genes_converted$ensembl_gene_id[cluster9_genes_converted$entrezgene_id %in% overlap_genes_entrez]
sample_index <- 1:length(overlap_genes)
plot_list_ANGIOGENESIS <- list()
for (i in 1:length(overlap_genes)) {
  gene = overlap_genes[sample_index[i]]
  plot_i <- (plot_gene_expression_log_across_cell_lines(gene, cell_line_indices = 1:19, color = F, CI = F))
  plot_list_ANGIOGENESIS[[i]] <-  plot_i
}

do.call(gridExtra::grid.arrange, c(plot_list_ANGIOGENESIS, ncol = 4))
```


Let's then `BILE_ACID_METABOLISM` gene set in cluster 1 across cell lines:

```{r echo=FALSE, message=FALSE}
BILE_ACID_METABOLISM_genes_entrez <- m_t2g$entrez_gene[m_t2g$gs_name == "HALLMARK_BILE_ACID_METABOLISM"]
cluster1_genes <- sorted_posterior_weights_df %>% filter(cluster == 1) %>% pull(id)
cluster1_genes_converted <- getBM(
  filters = "ensembl_gene_id",
  attributes = c("ensembl_gene_id", "entrezgene_id"),
  values = cluster1_genes,
  mart = mart
)
cluster1_genes_entrez <- cluster1_genes_converted$entrezgene_id
overlap_genes_entrez <- intersect(BILE_ACID_METABOLISM_genes_entrez, cluster1_genes_entrez)
overlap_genes <- cluster1_genes_converted$ensembl_gene_id[cluster1_genes_converted$entrezgene_id %in% overlap_genes_entrez]
sample_index <- 1:length(overlap_genes)
plot_list_BILE_ACID_METABOLISM <- list()
for (i in 1:length(overlap_genes)) {
  gene = overlap_genes[sample_index[i]]
  plot_i <- (plot_gene_expression_log_across_cell_lines(gene, cell_line_indices = 1:19, color = F, CI = F))
  plot_list_BILE_ACID_METABOLISM[[i]] <-  plot_i
}

do.call(gridExtra::grid.arrange, c(plot_list_BILE_ACID_METABOLISM, ncol = 4))
```

Now, let's compare the distribution of $\hat{\sigma}$ across cell lines for different genes.

For example, here we compare `ANGIOGENESIS` gene set in cluster 9 and `BILE_ACID_METABOLISM` gene set in cluster 1:

```{r echo=FALSE}
compute_sigma_means <- function(cell_line_indices) {

  # Take out the indices that are not in the range of cell_line_indices
  cell_line_indices <- cell_line_indices[cell_line_indices >= 1 & cell_line_indices <= 19]
  sigma_means_list <- list()  # Initialize list to store sigma_mean vectors

  # Loop over each cell line index
  for (cell_line_index in cell_line_indices) {
    # Construct the path to the result file
    result_file <- paste0(result_dir, "/L_matrix_", cell_line_index, ".rda")
    if (file.exists(result_file)) {
      # Load the result file
      load(result_file)
      # print(cell_line_index)
      fit.sqp <- mixsqp(L = L_matrix, log = TRUE, control = list(verbose = FALSE))
      posterior_matrix <- matrix(0, nrow = nrow(L_matrix), ncol = ncol(L_matrix))
      for(i in 1:nrow(L_matrix)){
        posterior_matrix[i,] <- exp(L_matrix[i,] - max(L_matrix[i,]) + log(fit.sqp$x))
        posterior_matrix[i,] <- posterior_matrix[i,]/sum(posterior_matrix[i,])
      }
      colnames(posterior_matrix) <- paste0(2,"_",psd_vec)

      # Extract sigma_val from column names of posterior_matrix
      sigma_val <- colnames(posterior_matrix)
      sigma_val <- as.numeric(sub(".*_", "", sigma_val))

      # Compute sigma_mean for the current cell line
      sigma_mean <- posterior_matrix %*% sigma_val

      # Add sigma_mean to the list
      sigma_means_list[[cell_line_index]] <- sigma_mean
    } else {
      message(paste("Result file not found for cell line index:", cell_line_index))
    }
  }

  # Combine sigma_mean vectors into a matrix
  sigma_means_matrix <- do.call(cbind, sigma_means_list)
  colnames(sigma_means_matrix) <- paste0("CellLine_", cell_line_indices)
  rownames(sigma_means_matrix) <- all_gene

  return(sigma_means_matrix)
}
sigma_means_matrix <- compute_sigma_means(1:19)
```

```{r echo=FALSE}
overlap_genes_entrez <- intersect(ANGIOGENESIS_genes_entrez, cluster9_genes_entrez)
overlap_genes <- cluster9_genes_converted$ensembl_gene_id[cluster9_genes_converted$entrezgene_id %in% overlap_genes_entrez]
sigma_means_matrix_AN <- sigma_means_matrix[rownames(sigma_means_matrix) %in% overlap_genes,]

# Convert the sigma_means_matrix_AN data to a data frame (if not already)
sigma_means_matrix_AN <- as.data.frame(sigma_means_matrix_AN)

# Add gene names as a column
sigma_means_matrix_AN$Gene <- rownames(sigma_means_matrix_AN)

# Reshape the data into long format
long_data <- melt(sigma_means_matrix_AN, id.vars = "Gene", 
                  variable.name = "CellLine", 
                  value.name = "SigmaMean")

plot1 <- ggplot(long_data, aes(x = Gene, y = SigmaMean, fill = Gene)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.2, size = 1, alpha = 0.5) +
  labs(
    title = "Angiogenesis Gene Set in Cluster 9",
    x = "Gene",
    y = "Sigma Mean",
    fill = "Gene"
  ) +
  theme_minimal() +
  ylim(c(0,3)) + 
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(size = 14, face = "bold"),
    axis.title = element_text(size = 12),
    legend.position = "none"
  )

overlap_genes_entrez <- intersect(BILE_ACID_METABOLISM_genes_entrez, cluster1_genes_entrez)
overlap_genes <- cluster1_genes_converted$ensembl_gene_id[cluster1_genes_converted$entrezgene_id %in% overlap_genes_entrez]
sigma_means_matrix_BAM <- sigma_means_matrix[rownames(sigma_means_matrix) %in% overlap_genes,]

# Convert the sigma_means_matrix_BAM data to a data frame (if not already)
sigma_means_matrix_BAM <- as.data.frame(sigma_means_matrix_BAM)

# Add gene names as a column
sigma_means_matrix_BAM$Gene <- rownames(sigma_means_matrix_BAM)

# Reshape the data into long format
long_data <- melt(sigma_means_matrix_BAM, id.vars = "Gene", 
                  variable.name = "CellLine", 
                  value.name = "SigmaMean")

plot2 <- ggplot(long_data, aes(x = Gene, y = SigmaMean, fill = Gene)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.2, size = 1, alpha = 0.5) +
  labs(
    title = "Bile Acid Metabolism Gene Set in Cluster 1",
    x = "Gene",
    y = "Sigma Mean",
    fill = "Gene"
  ) +
  theme_minimal() +
  ylim(c(0,3)) + 
  theme(
    axis.text.x = element_text(angle = 40, hjust = 1),
    plot.title = element_text(size = 12, face = "bold"),
    axis.title = element_text(size = 12),
    legend.position = "none"
  )

grid.arrange(plot1, plot2, ncol = 2)
```


Alternatively, we could also check how the distribution of $\hat{\sigma}$ changes across cell lines for a specific set of genes:

```{r echo=FALSE}
overlap_genes_entrez <- intersect(ANGIOGENESIS_genes_entrez, cluster9_genes_entrez)
overlap_genes <- cluster9_genes_converted$ensembl_gene_id[cluster9_genes_converted$entrezgene_id %in% overlap_genes_entrez]
sigma_means_matrix_AN <- sigma_means_matrix[rownames(sigma_means_matrix) %in% overlap_genes,]

# Convert the sigma_means_matrix_AN data to a data frame (if not already)
sigma_means_matrix_AN <- as.data.frame(sigma_means_matrix_AN)

# Add gene names as a column
sigma_means_matrix_AN$Gene <- rownames(sigma_means_matrix_AN)

# Reshape the data into long format
long_data <- melt(sigma_means_matrix_AN, id.vars = "Gene", 
                  variable.name = "CellLine", 
                  value.name = "SigmaMean")

plot1 <- ggplot(long_data, aes(x = CellLine, y = SigmaMean, fill = CellLine)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.2, size = 1, alpha = 0.5) +
  labs(
    title = "Angiogenesis Gene Set in Cluster 9",
    x = "Cell Lines",
    y = "Sigma Mean",
    fill = "Cell Lines"
  ) +
  theme_minimal() +
  ylim(c(0,3)) + 
  theme(
    axis.text.x = element_text(angle = 40, hjust = 1),
    plot.title = element_text(size = 12, face = "bold"),
    axis.title = element_text(size = 12),
    legend.position = "none"
  )

overlap_genes_entrez <- intersect(BILE_ACID_METABOLISM_genes_entrez, cluster1_genes_entrez)
overlap_genes <- cluster1_genes_converted$ensembl_gene_id[cluster1_genes_converted$entrezgene_id %in% overlap_genes_entrez]
sigma_means_matrix_BAM <- sigma_means_matrix[rownames(sigma_means_matrix) %in% overlap_genes,]

# Convert the sigma_means_matrix_BAM data to a data frame (if not already)
sigma_means_matrix_BAM <- as.data.frame(sigma_means_matrix_BAM)

# Add gene names as a column
sigma_means_matrix_BAM$Gene <- rownames(sigma_means_matrix_BAM)

# Reshape the data into long format
long_data <- melt(sigma_means_matrix_BAM, id.vars = "Gene", 
                  variable.name = "CellLine", 
                  value.name = "SigmaMean")

plot2 <- ggplot(long_data, aes(x = CellLine, y = SigmaMean, fill = CellLine)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.7) +
  geom_jitter(width = 0.2, size = 1, alpha = 0.5) +
  labs(
    title = "Bile Acid Metabolism Gene Set in Cluster 1",
    x = "Cell Line",
    y = "Sigma Mean",
    fill = "Cell Line"
  ) +
  theme_minimal() +
  ylim(c(0,3)) + 
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(size = 14, face = "bold"),
    axis.title = element_text(size = 12),
    legend.position = "none"
  )

grid.arrange(plot1, plot2, ncol = 2)  
```











