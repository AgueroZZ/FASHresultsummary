---
title: "Example: Expression Analysis"
output:
  workflowr::wflow_html:
    toc: false
editor_options:
  chunk_output_type: console
---

### **Setup**

We consider the (raw) gene expression data measured over 16 days as studied in [Strober et al, 2019](https://www.science.org/doi/10.1126/science.aaw0040). 
For simplicity of the presentation, we consider only one cell-line in this example. 
The dataset contains the raw expression counts of 16319 genes.

To model the true (log) expression level $f_i(t_j)$ of the $i$th gene at day $t_j$, we assume that the expression count $y_{i}(t_j)$ is Poisson distributed with mean $o_j\exp \left(f_i\left(t_j\right)\right)$, where $o_j$ is the library size at day $t_j$.


```{r include=FALSE}
library(BayesGP)
library(TMB)
library(Matrix)
library(splines)
library(parallel)
library(ggplot2)
library(reshape2)
library(mixsqp)
library(tidyverse)
cpp_dir <- paste0(getwd(), "/code/cpp")
fig_dir <- paste0(getwd(), "/output/expression")
result_dir <- paste0(getwd(), "/output/expression")
function_dir <- paste0(getwd(), "/code/function")
data_dir <- paste0(getwd(), "/data/expression_data")
source(paste0(function_dir, "/functions_fitting_Poisson_expression.R"))
compile(paste0(cpp_dir, "/Poisson_expression.cpp"))
compile(paste0(cpp_dir, "/Poisson_just_fixed_expression.cpp"))
dyn.load(TMB::dynlib(paste0(cpp_dir, "/Poisson_expression")))
dyn.load(TMB::dynlib(paste0(cpp_dir, "/Poisson_just_fixed_expression")))
num_cores <- 4
betaprec <- 1e-6
```

### **Model**

Assume most of the gene expression trajectories are expected to be linear, we therefore consider the following finite mixture prior for each gene expression level $f_i(t_j)$:
$$f_i(t) = \sum_{k=0}^K \pi_k \text{GP}_k(t).$$
For each $k$, the mixture component has the prior: $$Lf(t) = \sigma_k W(t), $$ with $W(t)$ being a Gaussian white noise process and $\sigma_k$ being the smoothness. 
Choosing $L = \frac{\partial^2}{\partial t^2}$, the base model that each $f_i$ being shrunk to is therefore $\text{Null}\{L\} = \text{span}\{1,t\}$.

### **Processing the expression data**

```{r}
all_data_names <- list.files(data_dir)
#### let's consider one cell-line for simplicity
load(paste0(data_dir, "/", all_data_names[1]))
str(expression_data_one_cell_line) 
```

Let's create one dataset for each gene:
```{r eval=FALSE}
num_knots <- 16
p <- 2
datasets <- list()
all_gene <- unique(expression_data_one_cell_line$Gene_id)
for (gene in all_gene) {
  datasets[[gene]] <- expression_data_one_cell_line %>% filter(Gene_id == gene)
  datasets[[gene]]$x <- as.numeric(datasets[[gene]]$Day)
  datasets[[gene]]$y <- datasets[[gene]]$value
}
save(datasets, file = paste0(result_dir, "/datasets.rda"))
```


```{r echo=FALSE}
num_knots <- 16
p <- 2
datasets <- list()
all_gene <- unique(expression_data_one_cell_line$Gene_id)
load(paste0(result_dir, "/datasets.rda"))
```


Compute the library sizes:
```{r}
size_vec <- numeric(length = nrow(datasets[[1]]))
for (i in 1:length(size_vec)) {
  all_counts <- unlist(lapply(datasets, function(x) {x$y[x$Day == (i-1)]}))
  size_vec[i] <- sum(all_counts)
}
log_size_vec <- log(size_vec)
```




### **Applying empirical Bayes**

```{r eval = FALSE}
psd_vec <- sort(unique(c(0, seq(0,3, length.out = 31))))

## set up a progress bar
L_vecs <- vector("list", length(datasets))
pb <- txtProgressBar(min = 0, max = length(datasets), style = 3)
for (i in 1:length(datasets)) {
  setTxtProgressBar(pb, i)
  dataset <- datasets[[i]]
  L_vecs[[i]] <- compute_log_likelihood_ospline_seq2(
    dataset = dataset,
    p = p,
    num_knots = num_knots,
    psd_iwp_vector = psd_vec,
    pred_step = 1,
    betaprec = betaprec,
    log_lib_size = log_size_vec
  )
}
L_matrix <- do.call(rbind, L_vecs)
save(L_matrix, file = paste0(result_dir, "/L_matrix.rda"))
```

```{r echo=FALSE}
psd_vec <- sort(unique(c(0, seq(0,3, length.out = 31))))
load(paste0(result_dir, "/L_matrix.rda"))
```

```{r}
fit.sqp <- mixsqp(L = L_matrix, log = TRUE)
numiter <- nrow(fit.sqp$progress)
plot(1:numiter,fit.sqp$progress$objective,type = "b",
     pch = 20,lwd = 2,xlab = "SQP iteration",
     ylab = "objective",xaxp = c(1,numiter,numiter - 1))
prior_weight <- data.frame(p = rep(p, each = length(psd_vec)), psd_iwp = psd_vec, prior_weight = fit.sqp$x)

posterior_matrix <- matrix(0, nrow = nrow(L_matrix), ncol = ncol(L_matrix))
for(i in 1:nrow(L_matrix)){
  posterior_matrix[i,] <- exp(L_matrix[i,] - max(L_matrix[i,]) + log(fit.sqp$x))
  posterior_matrix[i,] <- posterior_matrix[i,]/sum(posterior_matrix[i,])
}
colnames(posterior_matrix) <- paste0(p,"_",psd_vec)
posterior_weights_matrix <- posterior_matrix
```

### **Obtaining posteriors**

```{r, eval=FALSE}
num_datasets <- length(datasets)
num_weights <- sum(prior_weight$prior_weight != 0)
posterior_weights_matrix <- matrix(nrow = num_datasets, ncol = num_weights)

# Loop through each dataset and perform fitting
fitted_datasets <- list()
# create a progress bar
pb <- txtProgressBar(min = 0, max = num_datasets, style = 3)
for (i in seq_along(datasets)) {
  setTxtProgressBar(pb, i)
  dataset <- datasets[[i]]
  fit_result_final <- fit_ospline_with_prior2(
    num_cores = 1,
    dataset = dataset,
    num_knots = num_knots,
    prior_weight = prior_weight,
    betaprec = betaprec,
    pred_step = 1,
    log_lib_size = log_size_vec
  )
  posterior_weights_matrix[i, ] <- fit_result_final$posterior_weights[, "posterior_weight"]
  fitted_datasets[[i]] <- aggregate_fit_with_prior(x = dataset$x, fit_results_with_prior = fit_result_final, original = TRUE)$summary_df
}
names(fitted_datasets) <- all_gene
colnames(posterior_weights_matrix) <- paste(as.character(fit_result_final$posterior_weights[, "p"]),
                                            as.character(fit_result_final$posterior_weights[, "psd_iwp"]), sep = "_")
save(fitted_datasets, posterior_weights_matrix, file = paste0(result_dir, "/fitted_pos_results.rda"))
```

```{r}
posterior_weights_df <- as.data.frame(posterior_weights_matrix)
posterior_weights_df$id <- all_gene
melted_data <- melt(posterior_weights_df, id.vars = "id")
melted_data$variable2 <- sub("_.*", "", melted_data$variable)
melted_data$variable3 <- (round(as.numeric(sub("*._", "", melted_data$variable)), 3))
```

Plot a sorted version of this, based on the mean PSD in each gene:
```{r}
mean_psd <- apply(posterior_weights_matrix, 1, function(x) {
  weighted_psd <- as.numeric(sub("*._", "", colnames(posterior_weights_matrix)))
  sum(x * weighted_psd)
})
sorted_index <- order(mean_psd)
sorted_posterior_weights_matrix <- posterior_weights_matrix[sorted_index, ]
sorted_posterior_weights_df <- as.data.frame(sorted_posterior_weights_matrix)
sorted_posterior_weights_df$id <- all_gene[sorted_index]
melted_data_sorted <- melt(sorted_posterior_weights_df, id.vars = "id")
melted_data_sorted$variable2 <- sub("_.*", "", melted_data_sorted$variable)
melted_data_sorted$variable3 <- (round(as.numeric(sub("*._", "", melted_data_sorted$variable)), 3))

ggplot(melted_data_sorted, aes(x = factor(id, levels = sorted_posterior_weights_df$id), y = value, fill = variable3)) +
  geom_bar(stat = "identity") +
  labs(x = "Gene", y = "Weight", fill = "PSD") +
  ggtitle("Structure Plot of Posterior Weights") +
  coord_flip() +
  scale_fill_gradient(low = "white", high = "blue") +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),  
    panel.background = element_rect(fill = "white", colour = "grey"),
    plot.background = element_rect(fill = "white", colour = NA) 
  )
```


### **Clustering based on posterior weights**

Let's group them into `num_clusters` groups, based on the quantiles of the mean PSD:
```{r}
mean_psd_ordered <- mean_psd[sorted_index]
# num_clusters <- 22
# quantiles <- quantile(mean_psd_ordered, probs = seq(0, 1, 1/num_clusters))
quantiles <- c(0, 0.1, 0.2, 0.35, 0.5, 1, 1.7, 2.5, 2.95, 3)

quantile_groups <- cut(mean_psd_ordered, breaks = quantiles, 
                       include.lowest = TRUE, labels = FALSE)
table(quantile_groups)
num_clusters <- length(unique(quantile_groups))

sorted_posterior_weights_df$cluster <- quantile_groups
melted_data_quantiles <- melt(sorted_posterior_weights_df, id.vars = c("id", "cluster"))
melted_data_quantiles$variable2 <- sub("_.*", "", melted_data_quantiles$variable)
melted_data_quantiles$variable3 <- round(as.numeric(sub(".*_", "", melted_data_quantiles$variable)), 3)
melted_data_quantiles <- melted_data_quantiles %>% arrange(cluster)

# Ensure the 'id' factor is ordered according to the sorted mean_psd
melted_data_quantiles$id <- factor(melted_data_quantiles$id, levels = sorted_posterior_weights_df$id)

# Plotting with facets by cluster and proper sorting of 'id'
ggplot(melted_data_quantiles, aes(x = factor(id, levels = sorted_posterior_weights_df$id), y = value, fill = variable3)) +
  geom_bar(stat = "identity") +
  labs(x = "Gene", y = "Weight", fill = "PSD Level") +
  ggtitle("Structure Plot of Posterior Weights by Quantile Group") +
  coord_flip() +
  scale_fill_gradient(low = "white", high = "blue") +
  facet_wrap(~cluster, scales = "free_y") +  # Faceting by cluster while keeping order
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.background = element_rect(fill = "white", colour = "grey"),
    plot.background = element_rect(fill = "white", colour = NA),
    strip.background = element_rect(fill = "lightblue", colour = "deepskyblue", size = 1),
    strip.text = element_text(face = "bold")
  )
```


```{r echo=FALSE}
plot_gene_expression <- function(gene) {
  agg_result <- fitted_datasets[[gene]]
  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", col = "blue",
       cex = 0.5, ylim = c(0, max(datasets[[gene]]$y) * 1.2),
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
  points(datasets[[gene]]$Day, datasets[[gene]]$y, col = "black", cex = 0.5)
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}

plot_gene_expression_log <- function(gene) {
  agg_result <- fitted_datasets[[gene]]
  data_points <- datasets[[gene]]$y
  positive_points <- data_points[data_points > 0]  # Filter out non-positive values

  if (length(positive_points) == 0) {
    stop("No positive data points available for logarithmic plotting.")
  }

  min_y <- min(positive_points)
  max_y <- max(agg_result$upper)  # Assuming this is positive and makes sense in your context

  # Set the limits for the y-axis
  log_min_y <- min_y / 2  # Just a simple heuristic, can adjust based on your data's distribution
  log_max_y <- max_y * 1.2

  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", col = "blue",
       cex = 0.5, log = "y", ylim = c(log_min_y, log_max_y),
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
  points(datasets[[gene]]$Day, data_points, col = "black", cex = 0.5)
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}

plot_gene_expression_log_just_f <- function(gene, log_size_vec) {
  agg_result <- fitted_datasets[[gene]]
  agg_result[,c(2,3,4)] <-  agg_result[,c(2,3,4)]/exp(log_size_vec)
  min_y <- min(agg_result$lower)
  max_y <- max(agg_result$upper)  # Assuming this is positive and makes sense in your context

  # Set the limits for the y-axis
  log_min_y <- min_y / 2  # Just a simple heuristic, can adjust based on your data's distribution
  log_max_y <- max_y * 1.2

  plot(datasets[[gene]]$Day, agg_result$median, type = 'l', 
       main = paste0(gene), xlab = "Day", ylab = "Expression", col = "blue",
       cex = 0.5, log = "y", ylim = c(log_min_y, log_max_y),
       cex.main = 0.8, cex.lab = 0.7, cex.axis = 0.7)
  polygon(c(datasets[[gene]]$Day, rev(datasets[[gene]]$Day)),
          c(agg_result$lower, rev(agg_result$upper)),
          col = rgb(0.6, 0.8, 1, alpha = 0.3), border = NA)
}


# plot_gene_expression(gene)
plot_cluster_genes <- function(genes) {
  if(length(genes) < 16){
        plot_gene_expression(genes[1])
  }
  else{
      par(mfrow = c(4, 4), mar = c(4, 4, 2, 1))  # Adjust margins if necessary
      for (gene in genes[1:16]) {
        plot_gene_expression(gene)
      }
      par(mfrow = c(1, 1))
  }
}

plot_cluster_genes_log <- function(genes) {
  if(length(genes) < 16) {
      plot_gene_expression_log(genes[1])
  }
  else{
      par(mfrow = c(4, 4), mar = c(4, 4, 2, 1))  # Adjust margins if necessary
  for (gene in genes[1:16]) {
    plot_gene_expression_log(gene)
  }
  par(mfrow = c(1, 1))
  }
}
plot_cluster_genes_log_just_f <- function(genes, log_size_vec){
  if(length(genes) < 16) {
      plot_gene_expression_log_just_f(genes[1], log_size_vec)
  }
  else{
      par(mfrow = c(4, 4), mar = c(4, 4, 2, 1))  # Adjust margins if necessary
  for (gene in genes[1:16]) {
    plot_gene_expression_log_just_f(gene, log_size_vec)
  }
  par(mfrow = c(1, 1))
  }
}
# plot_cluster_genes(genes_cluster1)
```


```{r setup, include=FALSE}
# Define the number of genes and clusters
num_genes_per_cluster <- 16

# Automatically extract gene IDs for each cluster
genes_per_cluster <- list()
for (i in 1:num_clusters) {
  genes_per_cluster[[i]] <- sorted_posterior_weights_df$id[sorted_posterior_weights_df$cluster == i][1:num_genes_per_cluster]
}
```

<!-- ### **Smoothing result for each cluster (Overall expression level $o_j\exp(f_i(t_j))$** {.tabset .tabset-pills} -->

<!-- ```{r, results='asis'} -->
<!-- for (i in 1:num_clusters) { -->
<!--   cat(paste0("#### For cluster ", i, ":\n")) -->
<!--   # Dynamically evaluate the plotting function for each cluster -->
<!--   plot_cluster_genes(genes_per_cluster[[i]], log_size_vec) -->
<!-- } -->
<!-- ``` -->

<!-- ### **Smoothing result for each cluster (Just the function $f_i$ after Log)** {.tabset .tabset-pills} -->

<!-- ```{r} -->
<!-- for (i in 1:num_clusters) { -->
<!--   # Header for each cluster -->
<!--   cat(paste0("#### For cluster ", i, ":\n")) -->

<!--   # Dynamically evaluate the plotting function for each cluster -->
<!--   plot_cluster_genes_log_just_f(genes_per_cluster[[i]], log_size_vec) -->
<!-- } -->
<!-- ``` -->


### **Question: what genes are enriched in each of the cluster? **

```{r, message = FALSE, warning = FALSE}
library(clusterProfiler)
library(msigdbr)
library(org.Hs.eg.db)  # Assuming human genes
library(biomaRt)
library(clusterProfiler)
library(cowplot)

# Retrieve Hallmark gene sets for Homo sapiens
m_t2g <- msigdbr(species = "Homo sapiens", category = "H") %>% 
  dplyr::select(gs_name, entrez_gene)
mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

enrich_cluster <- function(cluster_id, q_val_cutoff = 0.05, pvalueCutoff = 0.05, melted_data_input) {
  genes_selected <- melted_data_input %>% filter(cluster == cluster_id) %>% pull(id) %>% as.character() %>% unique()
  
  genes_converted <- getBM(
  filters = "ensembl_gene_id", 
  attributes = c("ensembl_gene_id", "entrezgene_id"), 
  values = genes_selected, 
  mart = mart
  )
  
  # Extract Entrez IDs from the converted data
  entrez_gene_list <- genes_converted$entrezgene_id
  
  genes_converted_all <- getBM(
    filters = "ensembl_gene_id", 
    attributes = c("ensembl_gene_id", "entrezgene_id"), 
    values = melted_data_input$id %>% as.character() %>% unique(), 
    mart = mart
  )
  entrez_universe <- as.character(genes_converted_all$entrezgene_id)
  entrez_universe <- entrez_universe[!is.na(entrez_universe)]

  # Perform enrichment analysis using Hallmark gene sets
  enrich_res <- enricher(pAdjustMethod = "BH", 
                         entrez_gene_list, 
                         TERM2GENE = m_t2g, 
                         qvalueCutoff = q_val_cutoff, 
                         pvalueCutoff = pvalueCutoff, 
                         universe = entrez_universe)
  enrich_res
}
```


```{r}
enriched_list <- list()
for (i in 1:num_clusters) {
  # for each cluster, record the list of its enriched gene sets
  enrich_res <- enrich_cluster(cluster_id = i, q_val_cutoff = 0.05, melted_data_input = melted_data_quantiles)  # Adjust parameters as needed
  enriched_list[[i]] <- enrich_res$Description
  names(enriched_list)[i] <- paste0(i)
}

# Automatically create a list of all unique enriched terms
all_enriched_terms <- unique(unlist(enriched_list))

# Remove the "HALLMARK_" prefix from each term
all_enriched_terms_clean <- gsub("HALLMARK_", "", all_enriched_terms)

# Initialize a data frame with clusters as columns and terms as rows
enrichment_table <- data.frame(matrix(nrow = length(all_enriched_terms_clean), ncol = length(enriched_list)))
rownames(enrichment_table) <- all_enriched_terms_clean
colnames(enrichment_table) <- names(enriched_list)

# Fill the table with "yes" or "no"
for (cluster in names(enriched_list)) {
  for (term in all_enriched_terms_clean) {
    # Check if the term is present in the enriched list of the cluster (after removing "HALLMARK_")
    original_term <- paste0("HALLMARK_", term)  # Add back the prefix for comparison
    enrichment_table[term, cluster] <- ifelse(original_term %in% enriched_list[[cluster]], "yes", "no")
  }
}

# Display the resulting table
print(enrichment_table[,-2])
```



```{r eval = FALSE}
enriched_list <- list()  # To store enrichment results

for (i in 1:num_clusters) {
  # For each cluster, perform enrichment and store the results
  enrich_res <- enrich_cluster(cluster_id = i, q_val_cutoff = 1, melted_data = melted_data_quantiles)  # Set q_val_cutoff to 1 to ensure all p-values are returned
  
  # Store both the descriptions and p-values (not filtered by significance)
  enriched_list[[i]] <- data.frame(
    Description = enrich_res$Description, 
    PValue = enrich_res$pvalue  # Use the raw p-value
  )
  
  names(enriched_list)[i] <- paste0(i)
}

# Automatically create a list of all unique enriched terms
all_enriched_terms <- unique(unlist(lapply(enriched_list, function(x) x$Description)))

# Remove the "HALLMARK_" prefix from each term
all_enriched_terms_clean <- gsub("HALLMARK_", "", all_enriched_terms)

# Initialize a data frame with clusters as columns and terms as rows
enrichment_table <-
  data.frame(matrix(
    nrow = length(all_enriched_terms_clean),
    ncol = length(enriched_list)
  ))
rownames(enrichment_table) <- all_enriched_terms_clean
colnames(enrichment_table) <- names(enriched_list)

# Fill the table with p-values
for (cluster in names(enriched_list)) {
  for (term in all_enriched_terms_clean) {
    # Check if the term is present in the enriched list of the cluster
    original_term <- paste0("HALLMARK_", term)  # Add back the prefix for comparison
    term_in_cluster <- if (nrow(enriched_list[[cluster]]) > 0) {
      enriched_list[[cluster]]$Description == original_term
    } else {
      FALSE
    }
    
    # If the term is enriched, fill in the p-value; otherwise, compute the enrichment and add its p-value
    if (any(term_in_cluster)) {
      enrichment_table[term, cluster] <- round(enriched_list[[cluster]]$PValue[term_in_cluster], 3)
    } 
    else {
      # If not found in the original result, perform enrichment for the gene set specifically
      cluster_id <- as.numeric(cluster)
      genes_selected <- melted_data_quantiles %>% filter(cluster == cluster_id) %>% pull(id) %>% as.character() %>% unique()
      
      genes_converted <- getBM(
        filters = "ensembl_gene_id",
        attributes = c("ensembl_gene_id", "entrezgene_id"),
        values = genes_selected,
        mart = mart
      )
      
      # Extract Entrez IDs from the converted data
      entrez_gene_list <- genes_converted$entrezgene_id
      
      genes_converted_all <- getBM(
        filters = "ensembl_gene_id",
        attributes = c("ensembl_gene_id", "entrezgene_id"),
        values = melted_data_quantiles$id %>% as.character() %>% unique(),
        mart = mart
      )
      entrez_universe <- as.character(genes_converted_all$entrezgene_id)
      entrez_universe <- entrez_universe[!is.na(entrez_universe)]
      
      enrich_res_full <- enricher(entrez_gene_list,
                 TERM2GENE = m_t2g,
                 pvalueCutoff = 2, qvalueCutoff = 2,
                 universe = entrez_universe)
      
      
      specific_term <- enrich_res_full %>% filter(Description == original_term)
      
      # Add p-value if it exists
      if (nrow(specific_term) > 0) {
        enrichment_table[term, cluster] <- round(specific_term$p.adjust, 3)
      } else {
        enrichment_table[term, cluster] <- 1  # No p-value found
      }
    }
  }
}

# Display the resulting table with p-values
print(enrichment_table)
```


### **Question: what enriched gene sets were not enriched in Strober's analysis? **

Here are the enrichment result from Strober's analysis for comparison:

```{r echo=FALSE}
# Define the file path where the table is saved
file_path <- paste0(result_dir, "/gene_set_table_strober")

# Load the table using read.table, assuming tab-delimited format
gene_set_table <- read.table(file_path, header = TRUE, sep = "|", stringsAsFactors = FALSE, strip.white = TRUE)

# Optionally, you can remove any unnecessary row numbers or empty rows
gene_set_table <- gene_set_table[-1,]  # Remove the first row if it's a redundant header row
gene_set_table <- gene_set_table[, -1] # Remove the first column if it's a redundant row index
gene_set_table <- gene_set_table[, -ncol(gene_set_table)] # remove the last column

# Clean up column names (since separators may have caused extra spaces)
colnames(gene_set_table) <- c("Hallmark", 2, 4, 5, 6, 9, 11, 13, 16)

# If you want to handle NA values that result from conversion
gene_set_table[is.na(gene_set_table)] <- 0  # Replace NAs with 0, or handle them as needed

# Perform a comparison between the two tables
gene_set_table_strober <- gene_set_table 

# Define the significance threshold
significance_level <- 0.05

# Apply the conversion using ifelse for each relevant column
for (col in colnames(gene_set_table)[2:ncol(gene_set_table)]) {
  gene_set_table[[col]] <- ifelse(as.numeric(gene_set_table[[col]]) < significance_level, "yes", "no")
}

gene_set_table$Hallmark <- toupper(gsub(" ", "_", gene_set_table$Hallmark))

# Define the desired order based on enrichment_table
desired_order <- rownames(enrichment_table)

# Step 1: Get the union of gene sets from both tables
all_gene_sets <- unique(c(gene_set_table$Hallmark, desired_order))

# Step 2: Identify gene sets in the union that are missing from final_gene_set_table
missing_gene_sets <- setdiff(all_gene_sets, gene_set_table$Hallmark)

# Step 3: Create a data frame for the missing gene sets, with all values set to "no"
missing_rows <- data.frame(Hallmark = missing_gene_sets, matrix("no", nrow = length(missing_gene_sets), ncol = ncol(gene_set_table) - 1))
colnames(missing_rows) <- colnames(gene_set_table)

# Step 4: Add the missing rows to the final_gene_set_table
final_gene_set_table <- rbind(gene_set_table, missing_rows)

# Step 5: Reorder the rows of the final table to match the order of the union of gene sets
final_gene_set_table <- final_gene_set_table[match(all_gene_sets, final_gene_set_table$Hallmark), ]


final_gene_set_table_for_comparison <- final_gene_set_table %>% filter(Hallmark %in% desired_order)
final_gene_set_table_for_comparison <- final_gene_set_table_for_comparison[match(desired_order, final_gene_set_table_for_comparison$Hallmark), ]

get_first_yes_position <- function(column) {
  yes_positions <- which(column == "yes")
  if (length(yes_positions) == 0) {
    return(Inf)  # Return Inf if there are no "yes" entries
  } else {
    return(min(yes_positions))  # Return the position of the first "yes"
  }
}

# Apply the function to each column (excluding the Hallmark column)
column_order <- apply(final_gene_set_table_for_comparison[, -1], 2, get_first_yes_position)
# Reorder the columns based on the first "yes" position
ordered_columns <- order(column_order)
# Reorder the table's columns based on this order
final_gene_set_table_for_comparison <- final_gene_set_table_for_comparison[, c(1, ordered_columns + 1)]  # +1 to account for the Hallmark column
rownames(final_gene_set_table_for_comparison) <- final_gene_set_table_for_comparison$Hallmark
final_gene_set_table_for_comparison[,-1]
```

A few interesting observations:

- Many gene-sets are enriched in clusters identified from both approaches. In particular, cluster 7 from FASH identified MYOGENESIS, EPITHELIAL_MESENCHYMAL_TRANSITION, INFLAMMATORY_RESPONSE and TNFA_SIGNALING_VIA_NFKB as enriched gene sets, whereas the cluster 6 from Strober identified MYOGENESIS, EPITHELIAL_MESENCHYMAL_TRANSITION and TNFA_SIGNALING_VIA_NFKB.

- Clusters (especially cluster 9) from FASH identifies some interesting gene-sets that were missed by Strober's analysis, such as UV_RESPONSE_DN, INFLAMMATORY_RESPONSE, IL2_STAT5_SIGNALING, ANGIOGENESIS and HYPOXIA. Note that UV_RESPONSE_DN INFLAMMATORY_RESPONSE and IL2_STAT5_SIGNALING are all related to protective features to prevent external damage due to environment or pathogens. ANGIOGENESIS and HYPOXIA are related to the formation of new blood vessels and the response to low oxygen levels, respectively.

